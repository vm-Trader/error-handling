<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilingual Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 85%; padding: 12px 16px; border-radius: 20px; word-wrap: break-word; opacity: 0; transform: translateY(10px); animation: fadeIn 0.4s forwards; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        .chat-bubble-user { background-color: #3b82f6; color: white; border-bottom-right-radius: 4px; align-self: flex-end; }
        .chat-bubble-assistant { background-color: #e5e7eb; color: #1f2937; border-bottom-left-radius: 4px; align-self: flex-start; }
        #chat-container::-webkit-scrollbar { width: 6px; }
        #chat-container::-webkit-scrollbar-track { background: #f1f5f9; }
        #chat-container::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; transition: background-color 0.5s; }
        .copy-btn-icon { transition: transform 0.2s; }
        .copy-btn:active .copy-btn-icon { transform: scale(0.9); }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen">
    <div id="main-app" class="w-full max-w-lg mx-auto bg-white rounded-2xl shadow-2xl flex flex-col h-[90vh] overflow-hidden">
        <!-- Header -->
        <div class="bg-slate-800 text-white p-4 flex items-center justify-between shadow-md">
            <div>
                <h1 class="text-xl font-bold">Multilingual Assistant</h1>
                <p class="text-sm text-slate-300">Polish & Translate Instantly</p>
            </div>
            <div class="flex items-center gap-2">
                <div id="status-indicator" class="status-dot bg-yellow-400" title="Checking API Status..."></div>
                <p id="status-text" class="text-sm text-slate-300 font-medium"></p>
            </div>
        </div>

        <!-- Chat Area -->
        <div id="chat-container" class="flex-1 p-6 space-y-4 overflow-y-auto">
            <div class="chat-bubble chat-bubble-assistant">Welcome. Enter a message in English, Vietnamese, or Chinese to begin.</div>
        </div>

        <!-- Templates -->
        <template id="bubble-template">
            <div class="chat-bubble">
                <div class="flex items-start gap-2">
                    <span class="text-xl" id="bubble-emoji"></span>
                    <div>
                        <p class="font-semibold text-slate-800" id="bubble-title"></p>
                        <p class="mt-1 whitespace-pre-wrap" id="bubble-text"></p>
                        <button id="copy-btn" class="copy-btn mt-3 bg-slate-200 hover:bg-slate-300 text-slate-600 px-3 py-1 rounded-full text-sm flex items-center gap-1.5" style="display: none;">
                            <svg id="copy-icon" class="copy-btn-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
                            <svg id="check-icon" class="copy-btn-icon text-green-600" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><path d="M20 6 9 17l-5-5"/></svg>
                            <span id="copy-text">Copy</span>
                        </button>
                    </div>
                </div>
            </div>
        </template>
        <template id="error-bubble-template">
            <div class="chat-bubble chat-bubble-assistant bg-red-100 text-red-800 border border-red-200"></div>
        </template>

        <!-- Input Area -->
        <div class="p-4 bg-slate-50 border-t border-slate-200">
            <form id="message-form" class="flex items-center gap-3">
                <textarea id="message-input" rows="1" class="flex-1 p-3 bg-white border border-slate-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none" placeholder="Enter message..."></textarea>
                <button type="submit" class="bg-blue-600 text-white rounded-full p-3 hover:bg-blue-700 transition-transform duration-150 active:scale-95 disabled:bg-slate-400 disabled:cursor-not-allowed">
                     <svg id="send-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                     <div id="loading-spinner" class="animate-spin rounded-full h-6 w-6 border-b-2 border-white" style="display: none;"></div>
                </button>
            </form>
        </div>
    </div>

    <script>
        // ================== CONFIGURATION ==================
        const API_KEY = "AIzaSyDEzX8QpqzThzO3hmBYVLAh_w2nVyRhcrI";
        const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20";
        // ===================================================

        // --- DOM Elements ---
        const chatContainer = document.getElementById('chat-container');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const sendButton = messageForm.querySelector('button');
        const sendIcon = document.getElementById('send-icon');
        const loadingSpinner = document.getElementById('loading-spinner');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const bubbleTemplate = document.getElementById('bubble-template');
        const errorBubbleTemplate = document.getElementById('error-bubble-template');
        let outputContainer = null;

        // --- Event Listeners ---
        messageForm.addEventListener('submit', handleSubmission);
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSubmission(e);
            }
        });
        
        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', runHealthCheck);

        async function handleSubmission(e) {
            e.preventDefault();
            const inputText = messageInput.value.trim();
            if (!inputText || sendButton.disabled) return;
            
            clearPreviousOutput();
            toggleLoading(true);
            displayBubble('user', '💬', 'Your Input:', inputText);

            try {
                const result = await callGeminiMultilingualCoach(inputText);
                displayResults(result);
            } catch (error) {
                console.error("Error calling Gemini:", error);
                displayError("Sorry, there was an issue processing your request.");
            } finally {
                toggleLoading(false);
            }
        }

        // --- API & Core Logic ---
        async function runHealthCheck() {
            statusText.textContent = "Checking...";
            if (!navigator.onLine) {
                return updateStatus(false, "No internet connection", "You are not connected to the internet.");
            }
            try {
                const healthCheckPayload = { contents: [{ parts: [{ text: "Hi" }] }] };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(healthCheckPayload) });
                if (!response.ok) throw new Error(`API returned status ${response.status}`);
                updateStatus(true, "API Status: Online");
            } catch (error) {
                console.error("Health Check Failed:", error);
                updateStatus(false, `API Status: Offline - ${error.message}`, "Could not connect to the AI service.");
            }
        }

        async function callGeminiMultilingualCoach(text) {
            const systemPrompt = `
                🔹 SYSTEM ROLE
                You are a multilingual message assistant trained to help users write clear, natural, and professional sentences in Vietnamese, English, or Chinese, depending on the input language. Your purpose is to polish, translate, and coach — not just mechanically translate.
                🔸 CORE BEHAVIORAL GOALS
                You will receive raw input from the user in Vietnamese, English, or Chinese. You must:
                1. Detect the input language automatically.
                2. Polish the input: Output a short, natural, grammatically correct version in the same language.
                3. Translate that polished version into the other two languages.
                4. Follow distinct tone & politeness rules per language.
                5. Always return a structured JSON output with 4 fields.
                🔹 JSON OUTPUT FORMAT
                Return this structured JSON always:
                {
                  "inputLanguage": "Vietnamese" | "English" | "Chinese",
                  "polished": "<short, corrected sentence in input language>",
                  "translatedEnglish": "<natural English translation>",
                  "translatedVietnamese": "<natural Vietnamese translation>",
                  "translatedChinese": "<natural Chinese translation>"
                }
                ✍️ PERSONA & STYLE GUIDE BY LANGUAGE
                🇻🇳 Vietnamese: Polite but natural – write like a thoughtful staff member speaking to a senior colleague. Avoid overly formal phrases. Keep messages short: 1–2 sentences, max 30 words.
                🇬🇧 English: Friendly business tone — like a junior team member updating a manager. Avoid robotic or stiff expressions. Use short, direct, natural sentences. Max 2 sentences.
                🇨🇳 Chinese: Professional and courteous using 简体中文 only. Prefer standard business sentence structures. Max 2–3 lines.
                🛑 GENERAL CONSTRAINTS
                - Do not explain or justify the rewrite.
                - Do not include extra analysis or commentary in the output.
                - Only return clean, final structured JSON.
            `;
            const payload = {
                systemInstruction: { parts: [{ text: systemPrompt }] },
                contents: [{ parts: [{ text: `User message: "${text}"` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            inputLanguage: { type: "STRING" },
                            polished: { type: "STRING" },
                            translatedEnglish: { type: "STRING" },
                            translatedVietnamese: { type: "STRING" },
                            translatedChinese: { type: "STRING" }
                        },
                        required: ["inputLanguage", "polished", "translatedEnglish", "translatedVietnamese", "translatedChinese"]
                    }
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error ${response.status}`);
            const result = await response.json();
            const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonString) throw new Error("Invalid response structure from API.");
            return JSON.parse(jsonString);
        }

        // --- UI & Display Functions ---
        function displayResults({ inputLanguage, polished, translatedEnglish, translatedVietnamese, translatedChinese }) {
            outputContainer = document.createElement('div');
            outputContainer.className = 'space-y-4';
            chatContainer.appendChild(outputContainer);

            // Display polished version of the original language first
            const polishedEmoji = inputLanguage === 'English' ? '🇬🇧' : (inputLanguage === 'Vietnamese' ? '🇻🇳' : '🇨🇳');
            displayBubble('assistant', polishedEmoji, `Polished ${inputLanguage}`, polished);
            
            // Display translations
            const englishBubble = displayBubble('assistant', '🇬🇧', 'English Translation', translatedEnglish);
            const vietnameseBubble = displayBubble('assistant', '🇻🇳', 'Vietnamese Translation', translatedVietnamese);
            const chineseBubble = displayBubble('assistant', '🇨🇳', 'Chinese Translation', translatedChinese);
            
            // Add copy buttons
            addCopyToBubble(englishBubble, translatedEnglish);
            addCopyToBubble(vietnameseBubble, translatedVietnamese);
            addCopyToBubble(chineseBubble, translatedChinese);
        }

        function addCopyToBubble(bubble, text) {
            const copyBtn = bubble.querySelector('#copy-btn');
            copyBtn.style.display = 'flex';
            copyBtn.addEventListener('click', () => copyToClipboard(text, copyBtn));
        }
        
        function displayBubble(type, emoji, title, text) {
            const node = bubbleTemplate.content.cloneNode(true);
            const bubble = node.querySelector('.chat-bubble');
            bubble.classList.add(type === 'user' ? 'chat-bubble-user' : 'chat-bubble-assistant');
            
            node.querySelector('#bubble-emoji').textContent = emoji;
            node.querySelector('#bubble-title').textContent = title;
            node.querySelector('#bubble-text').textContent = text;
            
            const targetContainer = type === 'user' ? chatContainer : outputContainer;
            targetContainer.appendChild(node);
            scrollToBottom();
            return targetContainer.lastElementChild;
        }

        function displayError(message) {
            clearPreviousOutput();
            const node = errorBubbleTemplate.content.cloneNode(true);
            const bubble = node.querySelector('.chat-bubble');
            bubble.textContent = message;
            chatContainer.appendChild(node);
            scrollToBottom();
        }

        function clearPreviousOutput() {
            const userBubbles = chatContainer.querySelectorAll('.chat-bubble-user');
            if (userBubbles.length > 1) {
                 userBubbles[0].remove();
            }
            if (outputContainer) {
                outputContainer.remove();
                outputContainer = null;
            }
             const errorBubbles = chatContainer.querySelectorAll('.bg-red-100');
            errorBubbles.forEach(bubble => bubble.remove());
        }
        
        async function copyToClipboard(text, button) {
            const copyIcon = button.querySelector('#copy-icon');
            const checkIcon = button.querySelector('#check-icon');
            const copyText = button.querySelector('#copy-text');

            try {
                await navigator.clipboard.writeText(text);
                copyText.textContent = 'Copied!';
                copyIcon.style.display = 'none';
                checkIcon.style.display = 'inline-block';
            } catch (err) {
                console.warn('Clipboard API failed, falling back to execCommand.');
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = text;
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                try {
                    document.execCommand('copy');
                     copyText.textContent = 'Copied!';
                     copyIcon.style.display = 'none';
                     checkIcon.style.display = 'inline-block';
                } catch (execErr) {
                    console.error('Fallback copy failed:', execErr);
                    copyText.textContent = 'Copy Failed';
                }
                document.body.removeChild(tempTextarea);
            } finally {
                setTimeout(() => {
                    copyText.textContent = 'Copy';
                    copyIcon.style.display = 'inline-block';
                    checkIcon.style.display = 'none';
                }, 2000);
            }
        }

        function toggleLoading(isLoading) {
            sendButton.disabled = isLoading;
            messageInput.disabled = isLoading;
            loadingSpinner.style.display = isLoading ? 'block' : 'none';
            sendIcon.style.display = isLoading ? 'none' : 'block';
            if (!isLoading) {
                 messageInput.value = '';
                 messageInput.focus();
            }
        }

        function updateStatus(isOnline, title, userMessage = null) {
            statusIndicator.classList.remove('bg-yellow-400');
            statusIndicator.classList.add(isOnline ? 'bg-green-400' : 'bg-red-500');
            statusIndicator.title = title;
            statusText.textContent = isOnline ? "Working" : "Error";
            messageInput.disabled = !isOnline;
            sendButton.disabled = !isOnline;

            if (!isOnline && userMessage) {
                displayError(userMessage);
            }
        }
        
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>
