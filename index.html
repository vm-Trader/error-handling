<script>
        // ================== CONFIGURATION ==================
        const API_KEY = "AIzaSyDEzX8QpqzThzO3hmBYVLAh_w2nVyRhcrI";
        const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20";
        // ===================================================

        // --- DOM Elements ---
        const chatContainer = document.getElementById('chat-container');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const sendButton = messageForm.querySelector('button');
        const sendIcon = document.getElementById('send-icon');
        const loadingSpinner = document.getElementById('loading-spinner');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const bubbleTemplate = document.getElementById('bubble-template');
        const errorBubbleTemplate = document.getElementById('error-bubble-template');
        let outputContainer = null;

        // --- Event Listeners ---
        messageForm.addEventListener('submit', handleSubmission);
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSubmission(e);
            }
        });
        
        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', runHealthCheck);

        async function handleSubmission(e) {
            e.preventDefault();
            const inputText = messageInput.value.trim();
            if (!inputText || sendButton.disabled) return;
            
            clearPreviousOutput();
            toggleLoading(true);
            displayBubble('user', 'ðŸ’¬', 'Your Input:', inputText);

            try {
                const result = await callGeminiMultilingualCoach(inputText);
                displayResults(result);
            } catch (error) {
                console.error("Error calling Gemini:", error);
                displayError("Sorry, there was an issue processing your request.");
            } finally {
                toggleLoading(false);
            }
        }

        // --- API & Core Logic ---
        async function runHealthCheck() {
            statusText.textContent = "Checking...";
            if (!navigator.onLine) {
                return updateStatus(false, "No internet connection", "You are not connected to the internet.");
            }
            try {
                const healthCheckPayload = { contents: [{ parts: [{ text: "Hi" }] }] };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(healthCheckPayload) });
                if (!response.ok) throw new Error(`API returned status ${response.status}`);
                updateStatus(true, "API Status: Online");
            } catch (error) {
                console.error("Health Check Failed:", error);
                updateStatus(false, `API Status: Offline - ${error.message}`, "Could not connect to the AI service.");
            }
        }

        async function callGeminiMultilingualCoach(text) {
            const systemPrompt = `
                ðŸ”¹ SYSTEM ROLE
                You are a multilingual message assistant trained to help users write clear, natural, and professional sentences in Vietnamese, English, or Chinese, depending on the input language. Your purpose is to polish, translate, and coach â€” not just mechanically translate.
                ðŸ”¸ CORE BEHAVIORAL GOALS
                You will receive raw input from the user in Vietnamese, English, or Chinese. You must:
                1. Detect the input language automatically.
                2. Polish the input: Output a short, natural, grammatically correct version in the same language.
                3. Translate that polished version into the other two languages.
                4. Follow distinct tone & politeness rules per language.
                5. Always return a structured JSON output with 4 fields.
                ðŸ”¹ JSON OUTPUT FORMAT
                Return this structured JSON always:
                {
                  "inputLanguage": "Vietnamese" | "English" | "Chinese",
                  "polished": "<short, corrected sentence in input language>",
                  "translatedEnglish": "<natural English translation>",
                  "translatedVietnamese": "<natural Vietnamese translation>",
                  "translatedChinese": "<natural Chinese translation>"
                }
                âœï¸ PERSONA & STYLE GUIDE BY LANGUAGE
                ðŸ‡»ðŸ‡³ Vietnamese: Polite but natural â€“ write like a thoughtful staff member speaking to a senior colleague. Avoid overly formal phrases. Keep messages short: 1â€“2 sentences, max 30 words.
                ðŸ‡¬ðŸ‡§ English: Friendly business tone â€” like a junior team member updating a manager. Avoid robotic or stiff expressions. Use short, direct, natural sentences. Max 2 sentences.
                ðŸ‡¨ðŸ‡³ Chinese: Professional and courteous using ç®€ä½“ä¸­æ–‡ only. Prefer standard business sentence structures. Max 2â€“3 lines.
                ðŸ›‘ GENERAL CONSTRAINTS
                - Do not explain or justify the rewrite.
                - Do not include extra analysis or commentary in the output.
                - Only return clean, final structured JSON.
            `;
            const payload = {
                systemInstruction: { parts: [{ text: systemPrompt }] },
                contents: [{ parts: [{ text: `User message: "${text}"` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            inputLanguage: { type: "STRING" },
                            polished: { type: "STRING" },
                            translatedEnglish: { type: "STRING" },
                            translatedVietnamese: { type: "STRING" },
                            translatedChinese: { type: "STRING" }
                        },
                        required: ["inputLanguage", "polished", "translatedEnglish", "translatedVietnamese", "translatedChinese"]
                    }
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error ${response.status}`);
            const result = await response.json();
            const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonString) throw new Error("Invalid response structure from API.");
            return JSON.parse(jsonString);
        }

        // --- UI & Display Functions ---
        function displayResults({ inputLanguage, polished, translatedEnglish, translatedVietnamese, translatedChinese }) {
            outputContainer = document.createElement('div');
            outputContainer.className = 'space-y-4';
            chatContainer.appendChild(outputContainer);

            // Display polished version of the original language first
            const polishedEmoji = inputLanguage === 'English' ? 'ðŸ‡¬ðŸ‡§' : (inputLanguage === 'Vietnamese' ? 'ðŸ‡»ðŸ‡³' : 'ðŸ‡¨ðŸ‡³');
            displayBubble('assistant', polishedEmoji, `Polished ${inputLanguage}`, polished);
            
            // Conditionally display translations for the OTHER two languages
            if (inputLanguage !== 'English') {
                const englishBubble = displayBubble('assistant', 'ðŸ‡¬ðŸ‡§', 'English Translation', translatedEnglish);
                addCopyToBubble(englishBubble, translatedEnglish);
            }
            if (inputLanguage !== 'Vietnamese') {
                const vietnameseBubble = displayBubble('assistant', 'ðŸ‡»ðŸ‡³', 'Vietnamese Translation', translatedVietnamese);
                addCopyToBubble(vietnameseBubble, translatedVietnamese);
            }
            if (inputLanguage !== 'Chinese') {
                const chineseBubble = displayBubble('assistant', 'ðŸ‡¨ðŸ‡³', 'Chinese Translation', translatedChinese);
                addCopyToBubble(chineseBubble, translatedChinese);
            }
        }

        function addCopyToBubble(bubble, text) {
            const copyBtn = bubble.querySelector('#copy-btn');
            copyBtn.style.display = 'flex';
            copyBtn.addEventListener('click', () => copyToClipboard(text, copyBtn));
        }
        
        function displayBubble(type, emoji, title, text) {
            const node = bubbleTemplate.content.cloneNode(true);
            const bubble = node.querySelector('.chat-bubble');
            bubble.classList.add(type === 'user' ? 'chat-bubble-user' : 'chat-bubble-assistant');
            
            node.querySelector('#bubble-emoji').textContent = emoji;
            node.querySelector('#bubble-title').textContent = title;
            node.querySelector('#bubble-text').textContent = text;
            
            const targetContainer = type === 'user' ? chatContainer : outputContainer;
            targetContainer.appendChild(node);
            scrollToBottom();
            return targetContainer.lastElementChild;
        }

        function displayError(message) {
            clearPreviousOutput();
            const node = errorBubbleTemplate.content.cloneNode(true);
            const bubble = node.querySelector('.chat-bubble');
            bubble.textContent = message;
            chatContainer.appendChild(node);
            scrollToBottom();
        }

        function clearPreviousOutput() {
            // Remove the previous AI output container
            if (outputContainer) {
                outputContainer.remove();
                outputContainer = null;
            }
            // Remove all previous user inputs
            const userBubbles = chatContainer.querySelectorAll('.chat-bubble-user');
            userBubbles.forEach(bubble => bubble.remove());
            // Remove any previous error messages
            const errorBubbles = chatContainer.querySelectorAll('.bg-red-100');
            errorBubbles.forEach(bubble => bubble.remove());
        }
        
        async function copyToClipboard(text, button) {
            const copyIcon = button.querySelector('#copy-icon');
            const checkIcon = button.querySelector('#check-icon');
            const copyText = button.querySelector('#copy-text');

            try {
                await navigator.clipboard.writeText(text);
                copyText.textContent = 'Copied!';
                copyIcon.style.display = 'none';
                checkIcon.style.display = 'inline-block';
            } catch (err) {
                console.warn('Clipboard API failed, falling back to execCommand.');
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = text;
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                try {
                    document.execCommand('copy');
                     copyText.textContent = 'Copied!';
                     copyIcon.style.display = 'none';
                     checkIcon.style.display = 'inline-block';
                } catch (execErr) {
                    console.error('Fallback copy failed:', execErr);
                    copyText.textContent = 'Copy Failed';
                }
                document.body.removeChild(tempTextarea);
            } finally {
                setTimeout(() => {
                    copyText.textContent = 'Copy';
                    copyIcon.style.display = 'inline-block';
                    checkIcon.style.display = 'none';
                }, 2000);
            }
        }

        function toggleLoading(isLoading) {
            sendButton.disabled = isLoading;
            messageInput.disabled = isLoading;
            loadingSpinner.style.display = isLoading ? 'block' : 'none';
            sendIcon.style.display = isLoading ? 'none' : 'block';
            if (!isLoading) {
                 messageInput.value = '';
                 messageInput.focus();
            }
        }

        function updateStatus(isOnline, title, userMessage = null) {
            statusIndicator.classList.remove('bg-yellow-400');
            statusIndicator.classList.add(isOnline ? 'bg-green-400' : 'bg-red-500');
            statusIndicator.title = title;
            statusText.textContent = isOnline ? "Working" : "Error";
            messageInput.disabled = !isOnline;
            sendButton.disabled = !isOnline;

            if (!isOnline && userMessage) {
                displayError(userMessage);
            }
        }
        
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>

